<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>阶段四：UI优化与项目发布</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <header>
            <nav>
                <a href="index.html">课程总览</a>
                <a href="stage-1.html">阶段一：组件化</a>
                <a href="stage-2.html">阶段二：核心服务</a>
                <a href="stage-3.html">阶段三：城市管理</a>
                <a href="stage-4.html" class="active">阶段四：优化发布</a>
            </nav>
        </header>
        <main>
            <h1>阶段四：UI优化与项目发布</h1>

            <h2>1. 教学目标</h2>
            <ul>
                <li><strong>掌握高级UI交互</strong>：学习使用 <code>uni-popup</code> 实现弹窗，并通过 <code>props</code> 和 <code>emit</code> 实现父子组件间的交互。</li>
                <li><strong>提升用户体验(UX)</strong>：掌握在 <code>&lt;scroll-view&gt;</code> 中实现“下拉刷新”功能。</li>
                <li><strong>理解资源优化</strong>：(可选) 了解如何封装一个 <code>SvgIcon</code> 组件，以更灵活地管理和使用矢量图标。</li>
                <li><strong>掌握项目交付</strong>：学习配置 <code>manifest.json</code>，执行打包命令，并了解将项目上传到微信开发者工具进行发布的完整流程。</li>
            </ul>

            <h2>2. 优化与发布流程图 (Mermaid)</h2>
            <div class="mermaid">
            graph TD
                subgraph "UI 优化"
                    A[用户点击生活指数] --> B[LifeIndex.vue 发出 show-detail 事件];
                    B --> C[index.vue 监听到事件<br>更新 visible 和 currentIndex 状态];
                    C --> D[IndexDetailPopup.vue<br>根据 props 弹出显示详情];
                end

                subgraph "UX 优化"
                    E[用户在首页下拉] --> F[scroll-view 触发 refresherrefresh 事件];
                    F --> G[index.vue 调用 onRefresh 方法];
                    G --> H[设置 refreshing=true, 重新请求数据];
                    H --> I[数据返回后设置 refreshing=false<br>刷新动画收起];
                end

                subgraph "打包发布"
                    J[配置 manifest.json<br>填入AppID] --> K[执行打包命令<br>npm run build:mp-weixin];
                    K --> L[在微信开发者工具中<br>导入 dist/build/mp-weixin 目录];
                    L --> M[预览、测试后点击上传];
                end
            </div>

            <h2>3. 核心步骤详解</h2>
            
            <h3><span class="emoji-icon">🧩</span> 步骤一：实现生活指数详情弹窗</h3>
            <h5>设计流程</h5>
            <p><strong>目标</strong>：当用户点击首页的某个生活指数时，我们不应该跳转页面，而是弹出一个浮层来展示更详细的说明，这样交互更轻量。</p>
            <p><strong>设计决策</strong>：采用父子组件通信的方式。父组件 `index.vue` 负责管理弹窗的“是否显示”状态 (`visible`) 和“显示什么内容” (`currentIndex`)。当 `LifeIndex.vue` 被点击时，它只负责告诉父组件“我被点击了，相关数据是...”，而不关心弹窗如何显示。弹窗组件 `IndexDetailPopup.vue` 则更“单纯”，它只根据父组件给的 `props` 来决定自己是否显示、显示什么内容。</p>

            <h5>编码流程</h5>
            <ol>
                <li><strong>创建弹窗组件</strong>: 创建 `components/IndexDetailPopup.vue`。内部使用 `uni-popup`，并定义好 `visible` 和 `indexData` 两个 props，以及一个 `close` 事件。</li>
                <li><strong>监听Props变化</strong>: 在弹窗组件中，使用 `watch` 监听 `props.visible` 的变化，当 `true` 时打开 `uni-popup`，`false` 时关闭。</li>
                <li><strong>父组件管理状态</strong>: 在 `index.vue` 中，定义 `detailVisible` 和 `currentIndex` 两个 `ref` 变量。</li>
                <li><strong>连接父子</strong>:
                    <ul>
                        <li>在 `index.vue` 的模板中，监听 `LifeIndex` 的 `@show-detail` 事件，触发一个方法来修改 `detailVisible` 和 `currentIndex`。</li>
                        <li>将 `detailVisible` 和 `currentIndex` 作为 props 传入 `IndexDetailPopup` 组件。</li>
                        <li>监听 `IndexDetailPopup` 的 `@close` 事件，将 `detailVisible` 改为 `false`。</li>
                    </ul>
                </li>
            </ol>
            <details>
                <summary>点击展开/折叠 index.vue 与弹窗交互的相关代码</summary>
                <div><pre><code class="language-vue">&lt;template&gt;
    &lt;!-- ... 其他组件 ... --&gt;
    
    &lt;!-- 生活指数，监听子组件的 show-detail 事件 --&gt;
    &lt;LifeIndex :index-data="lifeIndices" @show-detail="showIndexDetail"&gt;&lt;/LifeIndex&gt;
      
    &lt;!-- 指数详情弹窗，传递 visible 状态并监听 close 事件 --&gt;
    &lt;IndexDetailPopup :visible="detailVisible" :index-data="currentIndex" @close="closePopup"&gt;&lt;/IndexDetailPopup&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from 'vue';
// ... 其他导入 ...

// 控制弹窗显隐的状态
const detailVisible = ref(false);
// 存储当前要展示的指数详情
const currentIndex = ref({});

// 显示指数详情（由 LifeIndex 组件触发）
const showIndexDetail = (index) => {
  currentIndex.value = index;
  detailVisible.value = true;
};

// 关闭弹窗（由 IndexDetailPopup 组件触发）
const closePopup = () => {
  detailVisible.value = false;
};
&lt;/script&gt;
</code></pre></div>
            </details>
            <hr>

            <h3><span class="emoji-icon">🚀</span> 步骤二：实现下拉刷新功能</h3>
            <h5>设计流程</h5>
            <p><strong>目标</strong>：为用户提供一个主动、便捷的方式来刷新天气数据。</p>
            <p><strong>设计决策</strong>：不使用页面级的全局下拉刷新，因为它会作用于整个窗口。我们选择 `scroll-view` 组件内置的下拉刷新功能，这样可以更精细地控制刷新区域，且实现起来更简单，只需在 `scroll-view` 上配置几个属性并绑定一个事件即可。</p>
            
            <h5>编码流程</h5>
            <ol>
                <li>在 `index.vue` 的模板中，找到最外层的 `&lt;scroll-view&gt;`。</li>
                <li>为其添加 `refresher-enabled="true"` 来开启下拉刷新功能。</li>
                <li>添加 `@refresherrefresh="onRefresh"` 来绑定下拉被触发时要执行的方法。</li>
                <li>添加 `:refresher-triggered="refreshing"`，将其同一个名为 `refreshing` 的 `ref` 变量绑定。这个变量用来告诉 `scroll-view` 何时开始/结束刷新动画。</li>
                <li>在脚本中，创建 `refreshing = ref(false)`。</li>
                <li>创建 `async` 方法 `onRefresh`。在此方法中，先设置 `refreshing.value = true`，然后 `await` 调用数据获取函数（如 `initData`），数据返回后，再设置 `refreshing.value = false`。</li>
            </ol>
            <details>
                <summary>点击展开/折叠 index.vue 下拉刷新相关代码</summary>
                <div><pre><code class="language-vue">&lt;template&gt;
  &lt;view class="weather-container"&gt;
    &lt;scroll-view 
      scroll-y 
      refresher-enabled="true" 
      @refresherrefresh="onRefresh"
      :refresher-triggered="refreshing"
      style="height: 100vh;"
    &gt;
      &lt;!-- 所有页面内容... --&gt;
    &lt;/scroll-view&gt;
  &lt;/view&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from 'vue';
// ... 其他导入和 ref 定义 ...

// 刷新状态
const refreshing = ref(false);

// ... 其他函数 ...

// 下拉刷新事件处理
const onRefresh = async () => {
  // 1. 显示刷新动画
  refreshing.value = true;
  
  // 2. 重新获取所有数据
  await initData(); // 假设 initData() 是一个获取所有页面数据的函数
  
  // 3. 数据获取完毕，隐藏刷新动画
  refreshing.value = false;
};
&lt;/script&gt;
</code></pre></div>
            </details>
            <hr>

            <h3><span class="emoji-icon">💻</span> 步骤三：自定义SVG图标组件 (<code>SvgIcon.vue</code>) (可选)</h3>
            <h5>设计流程</h5>
            <p><strong>目标</strong>: 提供一个统一的、可复用的 SVG 图标组件，方便地控制图标的名称、大小和颜色，并且比 <code>uni-icons</code> 更灵活，可以加载我们自己的 SVG 文件。</p>
            <p><strong>设计决策</strong>: 组件本质上是一个 <code>&lt;image&gt;</code> 标签。它接收 `name` prop，并根据这个 `name` 动态地拼接出 <code>/src/static/SvgIcon/</code> 目录下的对应 <code>.svg</code> 文件的路径。这样，我们只需要在 `static` 目录下放置 SVG 文件，就可以通过组件名来调用它们。</p>

            <h5>编码流程</h5>
            <ol>
                <li>创建 <code>/src/components/SvgIcon/SvgIcon.vue</code> 文件。</li>
                <li>在模板中，放置一个 <code>&lt;image&gt;</code> 标签。</li>
                <li>将其 `src` 属性动态绑定为一个基于 `name` prop 的路径，例如 `` :src="`/src/static/SvgIcon/${name}.svg`" ``。</li>
                <li>添加 `size` 和 `color` props 以便从外部控制样式。</li>
            </ol>
            <details>
                <summary>点击展开/折叠 SvgIcon.vue 源代码</summary>
                <div><pre><code class="language-vue">&lt;template&gt;
  &lt;image 
    class="weather-icon"
    :src="`/src/static/SvgIcon/${name}.svg`"
    mode="widthFix"
    :style="{ width: size + 'px', height: size + 'px', color: color }"
  /&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { defineProps } from 'vue'

// 定义组件属性，支持图标名、大小、颜色
const props = defineProps({
  name: { // 图标名（对应SVG文件名：sunny、wind、rain等）
    type: String,
    required: true
  },
  size: { // 图标尺寸，默认24px
    type: [Number, String],
    default: 24
  },
  color: { // 单色图标颜色（需SVG的fill设为currentColor）
    type: String,
    default: ''
  }
})
&lt;/script&gt;

&lt;style scoped&gt;
.weather-icon {
  height: auto;
  vertical-align: middle;
}
&lt;/style&gt;
</code></pre></div>
            </details>
            <hr>

            <h3><span class="emoji-icon">🚀</span> 步骤四：项目打包与发布</h3>
            <h5>设计流程</h5>
            <p><strong>目标</strong>：将我们的源代码转换成微信小程序平台可识别、可运行的代码包，并将其上传发布。</p>
            <p><strong>设计决策</strong>：遵循 `uni-app` 的官方流程。首先配置 `manifest.json` 文件，这是 `uni-app` 项目的“身份证”，里面包含了小程序的 AppID 等关键信息。然后利用 `npm` 脚本执行 `uni-app` 提供的编译命令，将项目打包成 `mp-weixin` 平台的代码。最后一步是使用微信开发者工具这个“官方上传渠道”，来导入和上传我们的代码包。</p>
            
            <h5>编码流程</h5>
            <ol>
                <li><strong>配置 <code>manifest.json</code></strong>: 打开项目根目录的 <code>manifest.json</code> 文件，在“微信小程序配置”中，填入从微信公众平台申请到的 <strong>AppID</strong>。</li>
                <li><strong>执行打包命令</strong>: 在项目根目录下打开终端，执行 `npm run build:mp-weixin`。</li>
                <li><strong>导入微信开发者工具</strong>: 等待打包成功后，会在根目录生成 `dist/build/mp-weixin` 文件夹。打开微信开发者工具，点击“导入”，项目目录选择这个 `mp-weixin` 文件夹。</li>
                <li><strong>上传版本</strong>: 在微信开发者工具中进行最后的预览和调试，确认无误后，点击右上角的“上传”按钮，填写版本信息即可上传。</li>
            </ol>
            <p>上传成功后，即可登录 <a href="https://mp.weixin.qq.com/" target="_blank">微信公众平台</a>，在 “版本管理” 中看到你刚上传的版本，后续可提交审核或设为体验版。</p>
            
            <h2>4. 课程总结与拓展任务</h2>
            <p><strong>拓展任务</strong>: 实现一个“骨架屏（Skeleton Screen）”加载效果。在 `index.vue` 中增加一个 `isLoading` 状态，在 `initData` 开始时设为 `true`，结束后设为 `false`。当 `isLoading` 为 `true` 时，用一些灰色的占位块来模拟 `CurrentEnvironment` 等组件的轮廓，为用户提供一个更平滑的加载预期。</p>

            <div class="stage-nav">
                <a href="stage-3.html">&larr; 返回阶段三</a>
                <a href="index.html">返回总览 &hookleftarrow;</a>
            </div>
        </main>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ startOnLoad: true });
    </script>
</body>
</html>