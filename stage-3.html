<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>阶段三：城市管理功能实现</title>
    <link rel="stylesheet" href="assets/style.css">
</head>
<body>
    <div class="container">
        <header>
            <nav>
                <a href="index.html">课程总览</a>
                <a href="stage-1.html">阶段一：组件化</a>
                <a href="stage-2.html">阶段二：核心服务</a>
                <a href="stage-3.html" class="active">阶段三：城市管理</a>
                <a href="stage-4.html">阶段四：优化发布</a>
            </nav>
        </header>
        <main>
            <h1>阶段三：城市管理功能实现</h1>

            <h2>1. 教学目标</h2>
            <ul>
                <li><strong>掌握页面导航</strong>：熟练运用 <code>uni.navigateTo</code> 和 <code>uni.navigateBack</code> 实现跨页面跳转与返回。</li>
                <li><strong>综合状态管理</strong>：学习在一个简易的 <code>store</code> 中同时管理对象（<code>cityInfo</code>）和列表（<code>myCities</code>），并实现增、删、持久化等操作。</li>
                <li><strong>掌握复合组件</strong>：学习使用 <code>uni-swipe-action</code> 实现列表的左滑删除功能，提升应用交互体验。</li>
                <li><strong>理解响应式联动</strong>：深入理解 Vue 3 的响应式核心——<code>computed</code> 和 <code>watch</code>，并利用它们实现跨页面状态同步，即城市页的修改能够自动触发首页的刷新。</li>
                <li><strong>完成功能闭环</strong>：将城市选择、状态更新、页面返回、数据刷新等环节串联起来，完成“城市管理”这一核心功能的完整开发。</li>
            </ul>

            <h2>2. 城市切换与数据刷新流程图 (Mermaid)</h2>
            <p>此图清晰地展示了从用户点击城市到首页刷新数据的完整响应式流程。</p>
            <div class="mermaid">
            graph TD
                subgraph "首页 index.vue"
                    A[用户点击城市名] --> B[调用 uni.navigateTo<br>跳转到城市页];
                    K[watch 监听器<br>watch currentCity, ...] -- 城市变化时触发 --> L[调用 updateWeather<br>刷新天气数据];
                end

                subgraph "城市管理页 city.vue"
                    C[页面加载 onMounted] --> D[从 store.js 获取<br>当前城市/热门城市/我的城市];
                    D --> E[渲染UI列表];
                    F[用户点击新城市] --> G[调用 selectCity 新城市];
                    G --> H[调用 location.js<br>获取新城市的完整信息];
                    H --> I[调用 store.js 的 setCityInfo<br>更新全局状态];
                    I --> J[调用 uni.navigateBack<br>返回首页];
                end

                subgraph "状态层 store.js"
                    M[cityInfo 状态改变]
                end
                
                subgraph "响应式系统 Vue"
                    N[computed 属性 currentCity<br>在 index.vue 中]
                end

                I --> M;
                M -- 通知 --> N;
                N -- 值变化 --> K;
            </div>

            <h2>3. 核心步骤详解</h2>

            <h3><img src="assets/storage-icon.svg" alt="Storage Icon" class="list-icon"> 步骤一：扩展 <code>store.js</code> 以支持城市列表</h3>
            <p>为了记录用户添加的城市，我们需要对 <code>utils/store.js</code> 进行扩展。</p>
            <ul>
                <li><strong>职责</strong>:
                    <ol>
                        <li>在 <code>store</code> 对象中新增 <code>myCities: []</code> 和 <code>hotCities: []</code> 两个数组。</li>
                        <li>增加 <code>addMyCity</code> 和 <code>removeMyCity</code> 方法，用于添加和删除“我的城市”列表中的项。</li>
                        <li>在这两个方法中，调用 <code>uni.setStorageSync</code>，确保列表的改动能被持久化。</li>
                        <li>修改 <code>initStore</code> 函数，使其在应用启动时，也能从本地存储中加载 <code>myCities</code> 列表。</li>
                    </ol>
                </li>
                <li><strong>知识点</strong>: 在 <code>reactive</code> 对象中操作数组，数组的 <code>push</code>, <code>splice</code>, <code>includes</code> 方法。</li>
            </ul>
            <details>
                <summary>点击展开/折叠 utils/store.js 扩展后源代码</summary>
                <div><pre><code class="language-javascript">import { reactive } from 'vue';

const store = reactive({
  cityInfo: { /* ... */ },
  // 新增：我的城市列表
  myCities: ['北京', '上海', '广州'],
  // 新增：热门城市列表
  hotCities: ['北京', '上海', '广州', '深圳', '杭州', '成都', '武汉', '西安']
});

// ... setCityInfo, getCityInfo ...

/**
 * 添加城市到我的城市列表
 * @param {string} city - 城市名称
 */
export const addMyCity = (city) => {
  // 如果城市不存在，则添加
  if (!store.myCities.includes(city)) {
    store.myCities.push(city);
    // 保存到本地存储
    uni.setStorageSync('myCities', store.myCities);
  }
};

/**
 * 从我的城市列表中删除城市
 * @param {number} index - 城市在列表中的索引
 */
export const removeMyCity = (index) => {
  if (index > -1) {
    store.myCities.splice(index, 1);
    // 保存到本地存储
    uni.setStorageSync('myCities', store.myCities);
  }
};

export const getMyCities = () => {
  return store.myCities;
};

export const getHotCities = () => {
  return store.hotCities;
};

// 初始化时从本地存储加载数据
const initStore = () => {
  const cityInfo = uni.getStorageSync('CityInfo');
  if (cityInfo) {
    store.cityInfo = cityInfo;
  }
  
  // 新增：加载我的城市列表
  const cities = uni.getStorageSync('myCities');
  if (cities && Array.isArray(cities)) {
    store.myCities = cities;
  }
};

initStore();

export default store;
</code></pre></div>
            </details>
            <hr>

            <h3><img src="assets/component-icon.svg" alt="Component Icon" class="list-icon"> 步骤二：构建城市管理页面 (<code>city.vue</code>)</h3>
            <p>这个页面是用户与城市列表交互的界面。</p>
            <ul>
                <li><strong>UI布局</strong>: 使用 <code>uni-nav-bar</code> 提供标题和返回按钮，<code>uni-search-bar</code> 提供搜索功能，页面主体分为“当前城市”、“热门城市”和“我的城市”三个区块。其中“我的城市”列表项包裹在 <code>uni-swipe-action</code> 中，以实现左滑删除。</li>
                <li><strong>逻辑实现</strong>:
                    <ol>
                        <li><code>onMounted</code> 中，从 <code>store.js</code> 调用 <code>getCityInfo</code>, <code>getHotCities</code>, <code>getMyCities</code> 获取数据，填充页面的初始状态。</li>
                        <li><code>selectCity(city)</code> 函数是核心。当用户点击一个城市时：
                            <ul>
                                <li>调用 <code>location.js</code> 的 <code>updateCityInfoByCity(city)</code> 获取该城市的完整信息（包括经纬度和<code>locationId</code>）。</li>
                                <li>调用 <code>store.js</code> 的 <code>setCityInfo()</code> 更新全局状态。</li>
                                <li>调用 <code>store.js</code> 的 <code>addMyCity()</code> 将其加入“我的城市”列表（如果不存在）。</li>
                                <li>调用 <code>uni.navigateBack()</code> 返回首页。</li>
                            </ul>
                        </li>
                        <li><code>deleteCity(index)</code> 函数在用户左滑删除时触发，调用 <code>store.js</code> 的 <code>removeMyCity()</code>。</li>
                    </ol>
                </li>
                <li><strong>知识点</strong>: <code>onMounted</code>, <code>uni-nav-bar</code>, <code>uni-swipe-action</code> 的使用，函数的导入与调用。</li>
            </ul>
            <details>
                <summary>点击展开/折叠 pages/city/city.vue 源代码</summary>
                <div><pre><code class="language-vue">&lt;template&gt;
  &lt;view class="city-container"&gt;
    &lt;uni-nav-bar title="城市管理" left-text="返回" left-icon="left" @click-left="onBack"&gt;&lt;/uni-nav-bar&gt;
    
    &lt;!-- 搜索区域 --&gt;
    &lt;view class="search-section"&gt;
      &lt;uni-search-bar placeholder="搜索城市" @input="onSearch"&gt;&lt;/uni-search-bar&gt;
    &lt;/view&gt;
    
    &lt;view class="city-list"&gt;
      &lt;!-- 热门城市 --&gt;
      &lt;view class="hot-cities"&gt;
        &lt;text class="section-title"&gt;热门城市&lt;/text&gt;
        &lt;view class="hot-cities-grid"&gt;
          &lt;view class="city-item" v-for="city in hotCities" :key="city" @click="selectCity(city)"&gt;
            {{ city }}
          &lt;/view&gt;
        &lt;/view&gt;
      &lt;/view&gt;
      
      &lt;!-- 我的城市 --&gt;
      &lt;view class="my-cities"&gt;
        &lt;text class="section-title"&gt;我的城市&lt;/text&gt;
        &lt;uni-swipe-action&gt;
          &lt;uni-swipe-action-item v-for="(city, index) in myCities" :key="city" :right-options="rightOptions" @click-right="deleteCity(index)"&gt;
            &lt;uni-list-item :title="city" @click="selectCity(city)"&gt;&lt;/uni-list-item&gt;
          &lt;/uni-swipe-action-item&gt;
        &lt;/uni-swipe-action&gt;
      &lt;/view&gt;
    &lt;/view&gt;
  &lt;/view&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref, onMounted } from 'vue';
import { getCityInfo, setCityInfo, getMyCities, getHotCities, removeMyCity, addMyCity } from '../../utils/store';
import { updateCityInfoByCity } from '../../utils/location';

const hotCities = ref([]);
const myCities = ref([]);

const rightOptions = [{ text: '删除', style: { backgroundColor: '#FF4757' } }];

const onBack = () => uni.navigateBack();

// 核心：选择城市
const selectCity = async (city) => {
  // 1. 获取新城市的完整信息
  const cityInfo = await updateCityInfoByCity(city);
  // 2. 更新全局状态
  setCityInfo(cityInfo);
  // 3. 添加到"我的城市"列表
  addMyCity(city);
  // 4. 返回首页
  uni.navigateBack();
};

// 删除城市
const deleteCity = (index) => {
  removeMyCity(index);
  // 直接修改 ref 来更新UI，因为 store 的数组变化不会直接通知到这里
  myCities.value = getMyCities(); 
};

// 页面加载时从 store 初始化数据
onMounted(() => {
  hotCities.value = getHotCities();
  myCities.value = getMyCities();
});
&lt;/script&gt;
</code></pre></div>
            </details>
            <hr>

            <h3><img src="assets/code-icon.svg" alt="Code Icon" class="list-icon"> 步骤三：改造首页以响应城市变化 (<code>index.vue</code>)</h3>
            <p>这是实现自动刷新的关键一步，也是 Vue 响应式魅力的体现。</p>
            <ul>
                <li><strong>实现原理</strong>: 我们不使用 <code>onShow</code> 来手动检查，而是利用 <code>computed</code> 和 <code>watch</code> 建立一个响应式链条。</li>
                <li><strong>实现逻辑</strong>:
                    <ol>
                        <li>在 <code>index.vue</code> 中，我们创建一个<strong>计算属性 <code>currentCity</code></strong>，它的值依赖于 <code>store.js</code> 中的 <code>getCityInfo()</code>。</li>
                        <li>我们创建一个 <strong><code>watch</code> 监听器</strong>，来“监视”这个 <code>currentCity</code> 计算属性的变化。</li>
                    </ol>
                </li>
                <li><strong>联动流程</strong>:
                    <ul>
                        <li>当在 <code>city.vue</code> 页面调用 <code>setCityInfo()</code> 时，<code>store.js</code> 中的 <code>reactive</code> 对象发生变化。</li>
                        <li>Vue 的响应式系统会侦测到这个变化，并通知所有依赖该状态的 <code>computed</code> 属性重新计算。</li>
                        <li><code>index.vue</code> 中的 <code>currentCity</code> 因此得到了一个新的值。</li>
                        <li><code>watch</code> 监听到 <code>currentCity</code> 的值发生了改变，于是执行其回调函数，调用 <code>updateWeather()</code>。</li>
                        <li>页面天气数据被刷新，完成闭环。</li>
                    </ul>
                </li>
            </ul>
            <details>
                <summary>点击展开/折叠 index.vue 响应式相关代码</summary>
                <div><pre><code class="language-vue">&lt;script setup&gt;
import { ref, onMounted, computed, watch } from 'vue';
import { getCityInfo, setCityInfo } from '../../utils/store';
// ...其他导入

// 1. 创建一个计算属性，它的值依赖于 store
const currentCity = computed(() => getCityInfo().city);

// ...其他 ref 定义...

const updateWeather = async () => {
  // ...更新天气的逻辑...
  console.log(`开始获取【${currentCity.value}】的天气数据...`);
};

const initData = async () => { /* ... */ };

onMounted(() => {
  initData();
});

// 2. 监听这个计算属性的变化
watch(currentCity, (newCity, oldCity) => {
  // 确保城市真的发生了变化再刷新
  if (newCity && newCity !== oldCity) {
    updateWeather();
  }
});
&lt;/script&gt;
</code></pre></div>
            </details>

            <h2>4. 课后任务 (可选)</h2>
            <ul>
                <li><strong>任务</strong>: 目前 <code>city.vue</code> 中的搜索功能是缺失的。请在 <code>utils/api.js</code> 中实现 <code>searchCity</code> 函数（可对接和风天气的城市搜索API，或暂时返回模拟数据），并在 <code>city.vue</code> 中完成搜索逻辑：用户输入时，调用此API，并将结果展示在一个临时的搜索结果列表中。</li>
                <li><strong>目的</strong>: 巩固 API 封装与调用，并练习处理用户输入、异步搜索和结果展示的常见场景。可以额外挑战一下“防抖”实现。</li>
            </ul>
            <hr>
            <p><strong>教师提示</strong>: 本阶段的精髓在于 <code>computed</code> + <code>watch</code> 组成的响应式数据流。务必向学生讲清这个“魔法”背后的原理，让他们理解 Vue 是如何自动完成状态同步的。这比使用 <code>onShow</code> 配合全局事件总线或手动比对的传统方法更优雅、更符合 Vue 的设计哲学。强调 <code>store</code> 作为单一数据源的重要性。</p>
            
            <div class="stage-nav">
                <a href="stage-2.html">&larr; 返回阶段二</a>
                <a href="stage-4.html">进入阶段四 &rarr;</a>
            </div>
        </main>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ startOnLoad: true });
        document.querySelectorAll('pre code').forEach((block) => {
            let content = block.innerHTML;
            content = content.replace(/</g, "&lt;").replace(/>/g, "&gt;");
            block.innerHTML = content;
        });
    </script>
</body>
</html>
